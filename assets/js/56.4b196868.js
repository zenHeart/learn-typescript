(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{418:function(t,e,r){"use strict";r.r(e);var a=r(42),v=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"工具类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#工具类型"}},[t._v("#")]),t._v(" 工具类型")]),t._v(" "),r("h2",{attrs:{id:"内建的公用类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内建的公用类型"}},[t._v("#")]),t._v(" 内建的公用类型")]),t._v(" "),r("p",[t._v("TypeScript 提供了一系列全局类型，用于方便使用。")]),t._v(" "),r("ul",[r("li",[t._v("多类型处理\n"),r("ul",[r("li",[r("code",[t._v("Record<K,T>")]),t._v(" 创建键名属于类型 K ，键值属于 T 的类型，"),r("a",{attrs:{href:""}},[t._v("范例 Record")])]),t._v(" "),r("li",[r("code",[t._v("Pick<T,K>")]),t._v(" 创建类型 T 中键名符合类型 K 的子类型，"),r("a",{attrs:{href:"./pick.ts"}},[t._v("范例 Record")])]),t._v(" "),r("li",[r("code",[t._v("Omit<T,K>")]),t._v(" 创建类型 T 中键名不符合类型 K 的子类型，效果是 "),r("code",[t._v("Pick")]),t._v(" 相对 "),r("a",{attrs:{href:"./pick.ts"}},[t._v("范例 Record")])]),t._v(" "),r("li",[r("code",[t._v("Exclude<T,K>")]),t._v(" 创建 T 类型中除去 K 类型后的子类型，类似集合的补集，"),r("a",{attrs:{href:"./exclude.ts"}},[t._v("范例 Exclude")])]),t._v(" "),r("li",[r("code",[t._v("Extract<T,K>")]),t._v(" 创建同时属于 T,K 类型的子类型，类似集合的交集，"),r("a",{attrs:{href:"./extract.ts"}},[t._v("范例 Extract")])]),t._v(" "),r("li",[r("code",[t._v("NonNullable<T>")]),t._v(" 创建 T 中非 null 和 undefined 的子类型，效果同 "),r("code",[t._v("Exclude<T,null|undefined>")]),t._v("，"),r("RouterLink",{attrs:{to:"/type-program/"}},[t._v("范例 NonNullable")])],1)])]),t._v(" "),r("li",[t._v("函数类子类型\n"),r("ul",[r("li",[r("code",[t._v("Parameters<T>")]),t._v(" 创建函数类型 T 的参数类型组成的元祖，"),r("a",{attrs:{href:"./parameters.ts"}},[t._v("范例 Parameters")])]),t._v(" "),r("li",[r("code",[t._v("ConstructorParameters<T>")]),t._v(" 创建构造器类型 T 的参数组成的元祖， [范例 ConstructorParameters]")]),t._v(" "),r("li",[r("code",[t._v("ReturnType<T>")]),t._v(" 创建函数类型 T 的返回值类型组成的元祖， "),r("a",{attrs:{href:""}},[t._v("范例 ReturnType")])]),t._v(" "),r("li",[r("code",[t._v("InstanceType<T>")]),t._v(" 创建类类型 T 对应的实例类型 "),r("a",{attrs:{href:"./instance-type.ts"}},[t._v("范例 InstanceType")])]),t._v(" "),r("li",[r("code",[t._v("ThisParameterType<T>")]),t._v(" 提取函数类型 T,this 参数对应的类型，"),r("a",{attrs:{href:"./this-parameters-type.ts"}},[t._v("范例 ThisParameterType")]),t._v(" "),r("blockquote",[r("p",[r("code",[t._v("--strictFunctionTypes")]),t._v(" 配置使能后生效")])])]),t._v(" "),r("li",[r("code",[t._v("OmitThisParameters<T>")]),t._v(" 创建函数类型 T除去 this 参数后的函数，"),r("a",{attrs:{href:"./omit-this-parameters.ts"}},[t._v("范例 OmitThisParameters")]),t._v(" "),r("blockquote",[r("p",[r("code",[t._v("--strictFunctionTypes")]),t._v(" 配置使能后生效")])])]),t._v(" "),r("li",[r("code",[t._v("ThisType<T>")]),t._v(" 创建函数类型 T除去 this 参数后的函数，"),r("a",{attrs:{href:"./this-type.ts"}},[t._v("范例 ThisType")]),t._v(" "),r("blockquote",[r("p",[r("code",[t._v("--noImplicitThis")]),t._v(" 配置使能后生效")])])])])]),t._v(" "),r("li",[t._v("类型修改\n"),r("ul",[r("li",[r("code",[t._v("Readonly<T>")]),t._v(" 创建类型 T 的所有属性为只读的类型，"),r("a",{attrs:{href:"./readonly.ts"}},[t._v("范例 Readonly")])]),t._v(" "),r("li",[r("code",[t._v("Required<T>")]),t._v(" 创建类型 T 的所有属性为必选的类型 "),r("a",{attrs:{href:"./required.ts"}},[t._v("范例 Required")])]),t._v(" "),r("li",[r("code",[t._v("Partial<T>")]),t._v(" 创建属于类型 T 的子类型，"),r("a",{attrs:{href:"./partial.ts"}},[t._v("范例 Partial")])])])])])])}),[],!1,null,null,null);e.default=v.exports}}]);