# 申明文件

当开发的模块作为第三方的包使用时， 如何保证他人可以利用模块中的类型检查，申明文件通过暴露模块的内部类型实现了此功能。


## 申明文件类型
根据包被使用的方式，定义申明文件的类型包含如下几类。

* **全局包申明** 例如 jQuery 等在全局对象上挂载方法的库
* **模块包申明** 采用 CommonJS 等规范等模块规范，被使用的包，大部分 node 环境下使用的 npm 包都符合此风格
* ****



### 全局申明
全局申明，当导入第三方库时可能可能会在全局环境绑定。变量和方法。
通过 `declare` 语句提前申明这些变量，避免 TypeScript 检查错误。
参见示例 [全局申明](./global-declare.ts)

```ts
// 声明全局变量 gVar
declare var gVar: number;
// 申明全局函数
declare function greet(str: string): void;
// 申明全局常量
declare const foo2: string;

gVar = 1;
console.log(gVar);
```

> 注意全局的常量和函数在这里只进行了申明，定义参见


## 定义申明文件
参见 https://devblogs.microsoft.com/typescript/writing-dts-files-for-types/


## 使用和发布申明文件

当发布自定义包或引入第三方的包时，如何暴露或引用类型申明，方法如下

### 自定义包的处理
若采用 TypeScript 编写的应用编译时添加 `--declaration` 会自动产生申明文件。

对于 js 编写的包， TypeScript 会利用如下方式解析申明文件。

1. 若包根目录定义了 `index.d.ts` 会被解析
2. 若 `package.json` 定义了 `files` 字段自行编写申明文件后，加入此字段
3. 若未定义则需在 `package.json` 使用 `types` 或 `typings` 字段包含申明文件。


### 第三方包
去 [types](https://microsoft.github.io/TypeSearch/) 搜索第三方包，安装对应的类型申明。

若未找到申明文件则参考 [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) 定义类型包提交到社区。

## 配置
<!-- TODO: 补充讲解 reference 的资料 -->
### [reference](https://www.typescriptlang.org/v2/docs/handbook/release-notes/overview.html#-reference-lib--reference-directives)
显示添加申明文件 

## 最佳实践
* [文件申明 Do's and Don'ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html)
* [DefinitelyTyped Best Practice](http://definitelytyped.org/guides/best-practices.html)


##  内置申明文件

<!-- TODO: 补充此处讲解 -->
[Including built-in type declarations with --lib](https://www.typescriptlang.org/v2/docs/handbook/release-notes/overview.html#including-built-in-type-declarations-with---lib)

##  申明合并 (declaration merging)
**申明合并** 是指 TypeScript 编译器合并两个或多个具有相同名字的独立申明为一个单独定义。

<<< ./examples/concept/declaration-merging/basic.ts

TypeScript 申明会创建如下类型的实体。
* **NameSpace** 一个命名空间,在该命名空间下采用 `.` 访问符获取类型值等信息
* **Type** 一个类型
* **Value** 在 JavaScript 中可见的值

参见下图理解,不同申明创建的结果。

| Declaration Type | Namespace | Type  | Value |
| :--------------- | :-------- | :---: | ----: |
| Namespace        | X         |       |     X |
| Class            |           |   X   |     X |
| Enum             |           |   X   |     X |
| Interface        |           |   X   |       |
| Type Alias       |           |   X   |       |
| Function         |           |       |     X |
| Variable         |           |       |     X |

理解不同申明会创建什么可以帮助你更好的理解哪些内容将会在申明合并时合并。

### 接口合并顺序
接口申明合并遵循如下规则。

**1. 每个接口的申明后申明的,合并后放在前面,并保持各接口内部顺序。**

<<< ./examples/concept/declaration-merging/interface-function.ts

**2. 如果函数表示中包含单个字符串字面量(不是字符串字面量的联合类型),合并后申明顺序会在规则 1 的基础上全部提前**

<<< ./examples/concept/declaration-merging/interface-function-literal.ts

### 命名空间合并
命名空间合并类似接口。具有如下规则

**1. 只合并包含 export 的申明**

<<< ./examples/concept/declaration-merging/namespace.ts


**2. 未导出只能在各命名空间内部访问**

<<< ./examples/concept/declaration-merging/namespace-scope.ts

### namespace 结合 class,function 和 枚举
利用 namespace 相当于给类扩充了静态方法或属性。

<<< ./examples/concept/declaration-merging/namespace-class.ts

同样也可以扩充函数的属性合法和方法

<<< ./examples/concept/declaration-merging/namespace-function.ts

采用申明合并,为枚举类型动态混入方法。

<<< ./examples/concept/declaration-merging/namespace-enum.ts

###  模块扩充 (Module Augmentation)
有时需要对导入模块注入新的方法,可以采用 `declare module 模块名`的方式
添加新的类型申明。

> module.ts

<<< ./examples/module/module-augmentation/module1.ts

> index.ts

<<< ./examples/module/module-augmentation/index.ts

注意使用时的两个限制
1. 扩充的模块名必须已经存在
2. 不能扩充 `default` 导出的内容

同样也可在全局空间进行扩充

<<< ./examples/declare/global-augmentation.ts

全局扩充只能在如下条件存在
1. 模块文件内,(TypeScript 检测到模块引入和导出语法就判别为模块)
2. 申明文件内

资料参考 [官方申明合并](申明合并 https://www.typescriptlang.org/docs/handbook/declaration-merging.html)

## 总结
TypeScript 采用申明文件解决不同项目之间类型共享的问题。