# 原始类型-枚举类型

本节介绍 TypeScript 对 JavaScript 扩充的为数不多的语言特性**枚举**。

## 枚举概述
枚举是一个在强类型语言中很常见的特性例如 `C`。它类似字面量,
也是基于有限的原始值创建，只是语义更友好!

采用 `enum 枚举名 { 标识符1, 标识符2,...}` 定义枚举,枚举内的标识符表示 **枚举成员(enum member)**。

<<< ./examples/types/enum/enum-define.ts{39}

注意示例中 Direction 的打印结果,枚举申明 `enum` 不仅创建了类型,同时会编译出实际的值,而字面量类型只会创建类型无法产生值,这是它们的核心区别。

:::tip
当需要引用实际的值时使用枚举,若只是单纯的需要限制变量的取值采用字面量类型。
:::

除了枚举成员到值,编译结果也包含值到枚举成员的映射,这是 **反向映射(Reverse mappings)**, 可以利用此特性利用值获取枚举成员名。


### 枚举的只读特性
枚举类型默认为只读，当试图对枚举值进行修改时，Typescript 静态检查会提示静态类型无法修改。

<<< ./examples/types/enum/enum-readonly.ts

也可以使用 [常量断言](../dig-type/type-assertion.md#常量断言)

## 枚举的类型
TypeScript 会默认给枚举变量的标识符绑定从 0 开始的自增数值。
你也可以人为修改枚举成员的取值。根据所取得值可细分为

* **数值枚举(Numeric enums)** 枚举成员的值为数字(默认行为)
* **字符串枚举(String enums)** 枚举成员的值为字符串
* **异构枚举(Heterogeneous enums)** 枚举成员的值为数值或字符串
  
<<< ./examples/types/enum/defalut-member-value.ts


注意输出的结果包含了

## 默认值的规则
之前示例中 TypeScript 对于未赋值的枚举成员会自动计算值,你只需要记住如下规则:

1. 当所有枚举成员都没有赋值时,默认从 0 开始,自增赋值
2. 当枚举成员之前的值为数值 n 时(对于起始位置则 n = 0),后续默认值从 n 开始自增赋值


<<< ./examples/types/enum/member-computed-value.ts{15}

注意高亮的行,由于 `FooBar1 = 10` 会导致后申明的成员变量替换 `Bar = 10` 的反向映射结果,即 `10: FooBar1` 取代 `10: Bar`。所以在申明是避免数值的重复。

那上述规则有什么实际意义呢?在业务开发中,为了更加友好的提示用户,
我们会定义一系列的业务状态码,若采用连续状态码会导致后续添加新的状态时不好分类,所以一般会将状态划分为区间方便后续补充,例如 0-99 为用户错误,100-199 为服务端错误等(实际上 HTTP 的状态码设计就是这样的)。此时就可以利用上述规则简化枚举定义。

<<< ./examples/types/enum/business-code.ts

## 计算赋值
除了直接赋值常量,枚举成员也可采用表达式计算赋值,这进一步增加了灵活性。

<<< ./examples/types/enum/member-computed-value.ts

表达式枚举的一个典型用例就是基于位操作的逻辑判断。在此之前你可以阅读 [MDN 位操作](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) 熟悉相关语法。

我们知道文件系统存在可读,可写,可执行的权限。在类 `Unix` 系统多用 如下符号表述 `w(可读)`,`r(可写)`,`x(可执行)`,`-(没有该项权限)` 对于一个文件这些权限是可以叠加的,如何表示上述状态,采用表格显示如下

| 权限   | 有   | 无   |
| :----- | :--- | :--- |
| 可执行 | x    | -    |
| 可写   | w    | -    |
| 可读   | r    | -    |

我们看到每个权限只分为有和无,这种二元性正好可以利用二进制的位进行表达。

| 二级制         | 0             | 1         |
| :------------- | :------------ | :-------- |
| 第一位(表示 x) | ▫️▫️▫️ 无权限 | ▫️▫️▪️ 有 |
| 第二位(表示 w) | ▫️▫️▫️ 无权限 | ▫️▪️▫️ 有 |
| 第三位(表示 r) | ▫️▫️▫️ 无权限 | ▪️▫️▫️ 有 |

上述逻辑正好可以利用枚举和表达式赋值表示。

<<< ./examples/types/enum/enum-bit-operation.ts

**注意计算赋值只针对数值枚举类型**

:::tip
在涉及多个二元可叠加状态的操作时,尝试使用位运算和枚举的计算属性
精简代码逻辑
:::

## 常量枚举
为了避免 TypeScript 对枚举类型创建实际的变量。
可以采用 `const enum` 申明常量枚举

<<< ./examples/types/enum/enum-const.ts

常量枚举类型会直接替换代码中引用常量成员的地方为对应的值。
注意由于常量枚举并未创建枚举对象,所以不支持直接访问枚举对象和反向映射。

:::tip
通过编译时传入 `--preserveConstEnums` 参数可以使常量枚举也创建枚举对象
:::

## 总结
利用枚举特性,我们可以更加语义化的定义一系列原始值。
知识点如下:

1. 采用 `enum 枚举名 {标识符1, 标识符2, ...}` 定义枚举类型,采用 `枚举名.标识符` 引用枚举成员,枚举类型会被编译为对象
2. 根据枚举成员的值,分为三种枚举类型
   1. **数值枚举** 值只能为 number 类型
   2. **字符串枚举** 值只能为 string 类型
   3. **异构枚举** 值可以为 number 或 string 类型
3. 枚举成员的默认值遵循如下规则
  1. 当所有枚举成员都没有赋值时,默认从 0 开始,自增赋值
  2. 当枚举成员之前的值为数值 n 时(对于起始位置则 n = 0),后续默认值从 n 开始自增赋值
  > 利用上述规则精简分段的状态码逻辑
4. 数值枚举的值可以为表达式,利用此特性优化位逻辑的状态处理
5. 采用 `const enum {}` 申明常量枚举类型
   1. 常量类型会在编译后替换位置
   2. 常量类型只能访问枚举成员,不支持访问枚举对象和反向映射
   3. 采用 `--preserveConstEnums` 是常量类型编译结果包含枚举对象